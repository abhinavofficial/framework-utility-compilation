# Introduction

A Bloom filter is a space-efficient probabilistic data structure that is used to test whether an element is a member of a set. For example, checking availability of username is set membership problem, where the set is the list of all registered username. The price we pay for efficiency is that it is probabilistic in nature that means, there might be some False Positive results. False positive means, it might tell that given username is already taken, but actually it’s not.

## Interesting Properties of Bloom Filters
* Unlike a standard hash table, a Bloom filter of a fixed size can represent a set with an arbitrarily large number of elements
* Adding an element never fails. However, the false positive rate increases steadily as elements are added until all bits in the filter are set to 1, at which point all queries yield a positive result.
* Bloom filters never generate false negative result, i.e., telling you that a username doesn't exist when it actually exists
* Deleting elements from filter is not possible because, if we delete a single element by clearing bits at indices generated by k hash functions, it might cause deletion of few other elements. Example – if we delete “geeks” (in given example below) by clearing bit at 1, 4 and 7, we might end up deleting “nerd” also, because bit at index 4 becomes 0 and bloom filter claims that “nerd” is not present.

## Operations that a Bloom Filter supports
* insert(x) : To insert an element in the Bloom Filter.
* lookup(x) : to check whether an element is already present in Bloom Filter with a positive false probability.

> We cannot delete an element in Bloom Filter.

**Probability of False positivity**: Let m be the size of bit array, k be the number of hash functions and n be the number of expected elements to be inserted in the filter, then the probability of false positive p can be calculated as:
```
P=\left ( 1-\left [ 1- \frac {1}{m} \right ]^{kn} \right )^k
```

**Size of Bit Array**: If expected number of elements n is known and desired false positive probability is p then the size of bit array m can be calculated as : ```m= -\frac {n\ln P}{(ln 2)^2}```


**Optimum number of hash functions**: The number of hash functions k must be a positive integer. If m is size of bit array and n is number of elements to be inserted, then k can be calculated as : ```k= \frac {m}{n} ln 2```

## Space Efficiency
Bloom filters do not store the data item at all. As we have seen they use bit array which allow hash collision. Without hash collision, it would not be compact.

## Choice of Hash Function
The hash function used in bloom filters should be independent and uniformly distributed. They should be fast as possible. Fast simple non-cryptographic hashes which are independent enough include _murmur_, _FNV series_ of hash functions and _Jenkins_ hashes.

Generating hash is major operation in bloom filters. Cryptographic hash functions provide stability and guarantee but are expensive in calculation. With increase in number of hash functions k, bloom filter become slow. Although non-cryptographic hash functions do not provide guarantee but provide major performance improvement.

## Example Implementation


LRU Cache is all about these 3 cases - Questions would be based upon these 3 cases each;
Expiration
Priority
Least used / recently used

Developing a component using DSA
LRU cache

They will be assessing based upon these parameters;
-> How you handle edge case
-> How you used DS & collection
-> How you implement the solution

Link for LRU Preparation: https://www.geeksforgeeks.org/lru-cache-implementation/


Keeping Strong hold on Trees & Binary search Trees for solving this problem. Using DSA how will approach faster results. Therefore, your approach for retrieving faster results is very prominent here for solving all the given cases.

You have to design a Cache - expiration time is given along with the priority data needs to be kept. You have to design the Cache

You should have knowledge about Caching , Data Structure to optimize the problem & Basic fundamental.. Plain/ Simple Cache will not do

Eviction should be based upon expiration then priority like that you have to design
Basically in-depth software development skills are checked
At a time only certain number of cache can be available what if new cache comes? Logic needed to be implemented based on given criteria.

Nothing more. Purely software development skills demonstration and live test
They gave example of cache memory utilisation along with removal criteria
We need to evict an expired  item
Least possible used item

How to implement hashmap
How to find index in array
How does hashing work
How to manage collision
How to implement heap
Linklist
LRU

binary trees
link list
different eviction strategy
hashmap
internal hashing work
how to implement heap
LRU
Comparater ka defination
how to handle Collisions
This might be discussed with you in all tech discussion
[09/08, 9:38 pm] BP HR: Least frequently used cache..
Low level design
more on the low level design on how are we going to implement it..
