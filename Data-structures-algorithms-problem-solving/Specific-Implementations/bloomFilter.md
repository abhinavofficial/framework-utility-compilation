# Introduction

A Bloom filter is a space-efficient probabilistic data structure that is used to test whether an element is a member of a set. For example, checking availability of username is set membership problem, where the set is the list of all registered username. The price we pay for efficiency is that it is probabilistic in nature that means, there might be some False Positive results. False positive means, it might tell that given username is already taken, but actually it’s not.

## Interesting Properties of Bloom Filters

* Unlike a standard hash table, a Bloom filter of a fixed size can represent a set with an arbitrarily large number of elements
* Adding an element never fails. However, the false positive rate increases steadily as elements are added until all bits in the filter are set to 1, at which point all queries yield a positive result.
* Bloom filters never generate false negative result, i.e., telling you that a username doesn't exist when it actually exists
* Deleting elements from filter is not possible because, if we delete a single element by clearing bits at indices generated by k hash functions, it might cause deletion of few other elements. Example – if we delete “geeks” (in given example below) by clearing bit at 1, 4 and 7, we might end up deleting “nerd” also, because bit at index 4 becomes 0 and bloom filter claims that “nerd” is not present.

## Operations that a Bloom Filter supports

* insert(x) : To insert an element in the Bloom Filter.
* lookup(x) : to check whether an element is already present in Bloom Filter with a positive false probability.

> We cannot delete an element in Bloom Filter.

**Probability of False positivity**: Let m be the size of bit array, k be the number of hash functions and n be the number of expected elements to be inserted in the filter, then the probability of false positive p can be calculated as:

$P=\left ( 1-\left [ 1- \frac {1}{m} \right ]^{kn} \right )^k$

**Size of Bit Array**: If expected number of elements n is known and desired false positive probability is p then the size of bit array m can be calculated as : ```m= -\frac {n\ln P}{(ln 2)^2}```

**Optimum number of hash functions**: The number of hash functions k must be a positive integer. If m is size of bit array and n is number of elements to be inserted, then k can be calculated as : ```k= \frac {m}{n} ln 2```

## Space Efficiency

Bloom filters do not store the data item at all. As we have seen they use bit array which allow hash collision. Without hash collision, it would not be compact.

## Choice of Hash Function

The hash function used in bloom filters should be independent and uniformly distributed. They should be as fast as possible. Fast simple non-cryptographic hashes which are independent enough include _murmur_, _FNV series_ of hash functions and _Jenkins_ hashes.

Generating hash is major operation in bloom filters. Cryptographic hash functions provide stability and guarantee but are expensive in calculation. With increase in number of hash functions k, bloom filter become slow. Although non-cryptographic hash functions do not provide guarantee but provide major performance improvement.

## Example Implementation
